================================================================================
                    Bridgify Mail Sync Architecture
                    "AI는 보조, 속도가 핵심"
================================================================================

[핵심 철학]
1. 즉시 반응 (< 100ms) - 메일은 로컬 캐시에서 먼저
2. AI는 점진적 - 메일 먼저 보여주고, AI 결과는 나중에 반영
3. 절대 데이터 유실 없음 - 실패해도 자동 복구
4. 투명한 상태 - 사용자에게 진행 상황 명확히 표시

================================================================================
                         동기화 시나리오 (4가지)
================================================================================

┌─────────────────────────────────────────────────────────────────────────────┐
│  시나리오 1: Initial Sync (최초 연결)                                        │
│  ─────────────────────────────────────                                      │
│  OAuth 완료 직후 → 메일박스 최초 동기화                                      │
│                                                                             │
│  문제점: 대용량 메일박스 (10만개+) → 타임아웃, 느린 첫 화면                  │
│                                                                             │
│  해결책: Progressive Loading                                                │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  1단계 (즉시, < 2초)                                                │   │
│  │     └─ 최근 50개 메일 가져와서 즉시 표시                            │   │
│  │     └─ SSE: "sync.first_batch" → UI 렌더링                          │   │
│  │                                                                     │   │
│  │  2단계 (백그라운드, 30초~)                                          │   │
│  │     └─ 나머지 메일 페이지네이션으로 동기화                          │   │
│  │     └─ 체크포인트 저장 (pageToken, 진행률)                          │   │
│  │     └─ SSE: "sync.progress" (34/100)                                │   │
│  │                                                                     │   │
│  │  3단계 (완료)                                                       │   │
│  │     └─ Watch 설정 (Push Notification)                               │   │
│  │     └─ SSE: "sync.completed"                                        │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  시나리오 2: Delta Sync (실시간 - Webhook)                                   │
│  ─────────────────────────────────────────                                  │
│  Gmail Pub/Sub → 새 메일 도착 알림                                          │
│                                                                             │
│  현재 구현: ✅ 잘 동작함                                                    │
│                                                                             │
│  플로우:                                                                    │
│  Gmail Webhook ──→ /webhook/gmail ──→ DeltaSync                            │
│       │                                                                     │
│       ├─→ PostgreSQL: 메타데이터 저장                                       │
│       ├─→ MongoDB: 본문 저장 (비동기)                                       │
│       ├─→ Redis Stream: AI 작업 발행                                        │
│       │       ├─→ ai.classify (분류)                                        │
│       │       └─→ ai.summarize (요약)                                       │
│       └─→ SSE: "email.new" → UI 즉시 반영                                   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  시나리오 3: Gap Sync (누락 복구)                                            │
│  ─────────────────────────────────────                                      │
│  서버 다운, Webhook 누락, History 만료 → 놓친 메일 복구                      │
│                                                                             │
│  문제점: Gmail History는 보통 1주일만 유지 (때로는 몇 시간)                  │
│         → 범위 벗어나면 404 에러                                            │
│                                                                             │
│  해결책: 앱 시작 시 Gap Check                                               │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  앱 시작 / 로그인                                                   │   │
│  │       │                                                             │   │
│  │       ▼                                                             │   │
│  │  ┌─────────────────────────────────────────────────────────────┐   │   │
│  │  │ 1. DB 캐시된 메일 즉시 표시 (< 100ms)                       │   │   │
│  │  └─────────────────────────────────────────────────────────────┘   │   │
│  │       │                                                             │   │
│  │       ▼ (백그라운드)                                                │   │
│  │  ┌─────────────────────────────────────────────────────────────┐   │   │
│  │  │ 2. History API로 갭 체크                                    │   │   │
│  │  │    - 저장된 historyId vs 현재 Gmail historyId               │   │   │
│  │  │    - 차이 있으면 → Partial Sync                             │   │   │
│  │  │    - 404 에러 → Full Sync 필요                              │   │   │
│  │  └─────────────────────────────────────────────────────────────┘   │   │
│  │       │                                                             │   │
│  │       ▼                                                             │   │
│  │  ┌─────────────────────────────────────────────────────────────┐   │   │
│  │  │ 3. 새 메일 발견 → SSE "email.new" → UI 업데이트             │   │   │
│  │  └─────────────────────────────────────────────────────────────┘   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  시나리오 4: Retry Sync (실패 복구)                                          │
│  ─────────────────────────────────────                                      │
│  Initial Sync 실패 → 사용자는 빈 화면 → 자동 복구 필요                       │
│                                                                             │
│  원인: 네트워크 오류, Gmail API 장애, 토큰 만료, 서버 재시작                 │
│                                                                             │
│  해결책: 자동 재시도 + 체크포인트                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  sync_states 테이블 확장:                                          │   │
│  │  ┌───────────────────────────────────────────────────────────┐     │   │
│  │  │ status: "error" | "retry_scheduled" | "pending"           │     │   │
│  │  │ retry_count: 3                                            │     │   │
│  │  │ next_retry_at: 2025-01-13 10:05:00                        │     │   │
│  │  │ checkpoint_page_token: "abc123..."                        │     │   │
│  │  │ checkpoint_synced_count: 34                               │     │   │
│  │  └───────────────────────────────────────────────────────────┘     │   │
│  │                                                                     │   │
│  │  재시도 전략:                                                       │   │
│  │  - 1차: 30초 후                                                    │   │
│  │  - 2차: 1분 후                                                     │   │
│  │  - 3차: 5분 후                                                     │   │
│  │  - 이후: 수동 재시도 버튼 (UI에서 "다시 시도" 제공)                │   │
│  │                                                                     │   │
│  │  체크포인트로 이어하기:                                             │   │
│  │  - 50개 중 34개 완료 후 실패 → 35번째부터 재시작                   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘

================================================================================
                         AI 파이프라인 (비동기)
================================================================================

핵심 원칙: "메일 표시는 AI 결과를 기다리지 않는다"

┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   새 메일 도착                                                              │
│        │                                                                    │
│        ├──────────────────────────────────────────────────────────────┐    │
│        │ (동기 - 즉시)                                                │    │
│        ▼                                                              │    │
│   ┌──────────────────┐                                                │    │
│   │ PostgreSQL 저장  │ ──→ SSE "email.new" ──→ UI 즉시 표시           │    │
│   │ (메타데이터)     │      (ai_status: "pending")                    │    │
│   └──────────────────┘                                                │    │
│        │                                                              │    │
│        └──────────────────────────────────────────────────────────────┘    │
│        │                                                                    │
│        ├──────────────────────────────────────────────────────────────┐    │
│        │ (비동기 - 백그라운드)                                        │    │
│        ▼                                                              │    │
│   ┌──────────────────┐                                                │    │
│   │ MongoDB 저장     │ (본문 캐시)                                    │    │
│   │ + Redis 발행    │                                                │    │
│   └────────┬─────────┘                                                │    │
│            │                                                          │    │
│            ▼                                                          │    │
│   ┌──────────────────────────────────────────────────────────────┐   │    │
│   │ Worker Pool                                                   │   │    │
│   │   │                                                           │   │    │
│   │   ├─→ ai.classify ──→ 분류 완료 ──→ DB 업데이트              │   │    │
│   │   │                         │                                 │   │    │
│   │   │                         └─→ SSE "email.classified"       │   │    │
│   │   │                                    │                      │   │    │
│   │   │                                    ▼                      │   │    │
│   │   │                              UI 카테고리 반영             │   │    │
│   │   │                                                           │   │    │
│   │   └─→ ai.summarize ──→ 요약 완료 ──→ DB 업데이트             │   │    │
│   │                              │                                │   │    │
│   │                              └─→ SSE "email.summarized"      │   │    │
│   │                                         │                     │   │    │
│   │                                         ▼                     │   │    │
│   │                                   UI 요약 표시                │   │    │
│   └──────────────────────────────────────────────────────────────┘   │    │
│                                                                       │    │
│        └──────────────────────────────────────────────────────────────┘    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

================================================================================
                         SyncManager 상태 머신
================================================================================

┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   [none] ──────────────────────────────────────────────────────────────┐   │
│     │ (OAuth 연결 완료)                                                │   │
│     ▼                                                                  │   │
│   [pending] ─────────────────────────────────────────────────────┐     │   │
│     │ (InitialSync 시작)                                         │     │   │
│     ▼                                                            │     │   │
│   [syncing] ──────────────────────────┬──────────────────────────│─────│   │
│     │                                 │                          │     │   │
│     │ (성공)                          │ (실패)                   │     │   │
│     ▼                                 ▼                          │     │   │
│   [idle] ◀────────────────────── [error]                         │     │   │
│     │                                 │                          │     │   │
│     │ (앱 시작 시)                    │ (자동 재시도)            │     │   │
│     ▼                                 ▼                          │     │   │
│   [gap_checking] ──────────┐    [retry_scheduled] ───────────────┘     │   │
│     │                      │          │                                │   │
│     │ (갭 발견)            │          │ (재시도 시작)                  │   │
│     ▼                      │          └───────────────────────────────►│   │
│   [gap_syncing] ───────────┘                                           │   │
│     │                                                                  │   │
│     │ (완료)                                                           │   │
│     └──────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

================================================================================
                    Superhuman 대비 차별화 포인트
================================================================================

┌────────────────────┬─────────────────────────┬──────────────────────────────┐
│ 문제점             │ Superhuman              │ Bridgify                     │
├────────────────────┼─────────────────────────┼──────────────────────────────┤
│ AI 속도            │ AI 추가할수록 느려짐    │ AI는 비동기, 메일은 즉시     │
│                    │ (2025년 불만 급증)      │ SSE로 점진적 업데이트        │
├────────────────────┼─────────────────────────┼──────────────────────────────┤
│ 초기 로딩          │ Electron 앱 느림        │ Progressive Loading          │
│                    │                         │ 50개 즉시 → 나머지 백그라운드│
├────────────────────┼─────────────────────────┼──────────────────────────────┤
│ 동기화 실패        │ 드래프트 동기화 안 됨   │ 자동 재시도 + 체크포인트     │
│                    │ 복구 어려움             │ 이어하기 지원                │
├────────────────────┼─────────────────────────┼──────────────────────────────┤
│ 장애               │ 2년간 159회+ 장애       │ Offline-First                │
│                    │ 서버 의존도 높음        │ 로컬 캐시 먼저, 서버는 동기화│
├────────────────────┼─────────────────────────┼──────────────────────────────┤
│ 상태 투명성        │ 진행 상황 불명확        │ "동기화 중 (34/100)"         │
│                    │                         │ "AI 처리 중..."              │
│                    │                         │ "오프라인 - 3개 대기 중"     │
├────────────────────┼─────────────────────────┼──────────────────────────────┤
│ AI 제어            │ AI 끄는 옵션 없음       │ AI 토글 on/off 제공          │
└────────────────────┴─────────────────────────┴──────────────────────────────┘

================================================================================
                         현재 문제점 및 병목
================================================================================

┌─────────────────────────────────────────────────────────────────────────────┐
│  문제 1: 개별 DB 조회로 인한 N+1 문제                                        │
│  ─────────────────────────────────────────                                  │
│                                                                             │
│  현재 코드 (느림):                                                          │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  for _, msg := range listResult.Messages {  // 50개                 │   │
│  │      existing, _ := mailRepo.GetByExternalID(ctx, connID, msg.ID)   │   │
│  │      // ❌ 50번의 DB 쿼리 = 50 * 10ms = 500ms                       │   │
│  │  }                                                                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  해결책 (배치 조회):                                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  externalIDs := extractIDs(listResult.Messages)                     │   │
│  │  existingMap := mailRepo.GetByExternalIDs(ctx, connID, externalIDs) │   │
│  │  // ✅ 1번의 DB 쿼리 = 10ms                                         │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  예상 개선: 500ms → 10ms (50배 향상)                                        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  문제 2: Worker Pool 비효율                                                  │
│  ─────────────────────────────────────────                                  │
│                                                                             │
│  현재: 단순 goroutine + 채널                                                │
│  - 동적 스케일링 없음                                                       │
│  - 배치 처리 없음 (1개씩 처리)                                              │
│  - Rate limiting 없음 (Gmail API 429 에러 위험)                             │
│                                                                             │
│  해결책: go-pkgz/pool 라이브러리 적용                                       │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  특징:                                                              │   │
│  │  - WithBatchSize(10) → 10개씩 묶어서 처리                          │   │
│  │  - WithWorkers(8) → 동적 워커 수 조절                              │   │
│  │  - errgroup 대비 41% 성능 향상                                      │   │
│  │  - 메트릭 수집 지원                                                 │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  문제 3: 동기식 저장으로 인한 응답 지연                                      │
│  ─────────────────────────────────────────                                  │
│                                                                             │
│  현재 플로우 (느림):                                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  Gmail API → 중복체크 → DB저장 → AI발행 → 응답                      │   │
│  │              (500ms)   (100ms)  (50ms)                              │   │
│  │                                                                     │   │
│  │  총 지연: ~650ms                                                    │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  최적화 플로우:                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  Gmail API → 배치중복체크 → 즉시응답 → (비동기) DB저장/AI발행       │   │
│  │              (10ms)        (즉시)     (Worker에서 처리)             │   │
│  │                                                                     │   │
│  │  총 지연: ~10ms (65배 향상)                                         │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

================================================================================
                         성능 최적화 전략
================================================================================

┌─────────────────────────────────────────────────────────────────────────────┐
│  최적화 1: 배치 DB 조회                                                      │
│  ─────────────────────────────────────────                                  │
│                                                                             │
│  구현:                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  // port/out/mail_repository.go                                     │   │
│  │  GetByExternalIDs(ctx, connectionID int64, externalIDs []string)    │   │
│  │      → map[string]*MailEntity                                       │   │
│  │                                                                     │   │
│  │  // SQL (IN 절 사용)                                                │   │
│  │  SELECT * FROM emails                                               │   │
│  │  WHERE connection_id = $1 AND external_id = ANY($2)                 │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  적용 위치:                                                                 │
│  - mail.go: fetchFromProviderWithToken()                                   │
│  - sync.go: processMessages(), saveEmailWithBody()                         │
│  - mail_processor.go: ProcessSave()                                        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  최적화 2: 지능형 Worker Pool (go-pkgz/pool)                                 │
│  ─────────────────────────────────────────                                  │
│                                                                             │
│  설치: go get github.com/go-pkgz/pool                                      │
│                                                                             │
│  구현:                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  import "github.com/go-pkgz/pool"                                   │   │
│  │                                                                     │   │
│  │  p := pool.New[*EmailJob](workers,                                  │   │
│  │      pool.WithBatchSize(10),           // 10개씩 배치 처리          │   │
│  │      pool.WithContinueOnError(),       // 에러 시 계속 진행         │   │
│  │  )                                                                  │   │
│  │                                                                     │   │
│  │  p.Go(func(jobs []*EmailJob) error {                                │   │
│  │      // 배치 DB 저장                                                │   │
│  │      return mailRepo.BulkUpsert(ctx, jobs)                          │   │
│  │  })                                                                 │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  벤치마크 (1,000,000 작업, 8 workers):                                      │
│  - errgroup: 1.878s                                                        │
│  - go-pkgz/pool: 1.105s (41% 빠름)                                         │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  최적화 3: Redis 캐시 레이어                                                 │
│  ─────────────────────────────────────────                                  │
│                                                                             │
│  목적: 최근 조회한 ExternalID를 캐싱하여 DB 조회 최소화                      │
│                                                                             │
│  구현:                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  // 키: email:exists:{connectionID}                                 │   │
│  │  // 값: Set of ExternalIDs (5분 TTL)                                │   │
│  │                                                                     │   │
│  │  func (r *MailRepo) ExistsInCache(connID, extID) bool {             │   │
│  │      return redis.SIsMember(ctx, key, extID)                        │   │
│  │  }                                                                  │   │
│  │                                                                     │   │
│  │  func (r *MailRepo) AddToCache(connID, extIDs []string) {           │   │
│  │      redis.SAdd(ctx, key, extIDs...)                                │   │
│  │      redis.Expire(ctx, key, 5*time.Minute)                          │   │
│  │  }                                                                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  플로우:                                                                    │
│  1. Redis 캐시 체크 (0.1ms)                                                │
│  2. 캐시 미스 → DB 배치 조회 (10ms)                                        │
│  3. 결과를 Redis에 캐싱                                                    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

================================================================================
                    Phase 0: 성능 최적화 구현 상세
================================================================================

┌─────────────────────────────────────────────────────────────────────────────┐
│  Task 0-1: GetByExternalIDs 배치 조회 구현                                   │
│  ─────────────────────────────────────────                                  │
│  상태: [x] 완료                                                             │
│                                                                             │
│  파일: adapter/out/persistence/mail_adapter.go                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  func (a *MailAdapter) GetByExternalIDs(                            │   │
│  │      ctx context.Context,                                           │   │
│  │      connectionID int64,                                            │   │
│  │      externalIDs []string,                                          │   │
│  │  ) (map[string]*out.MailEntity, error)                              │   │
│  │                                                                     │   │
│  │  SQL: SELECT * FROM emails                                          │   │
│  │       WHERE connection_id = $1 AND external_id = ANY($2)            │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  인터페이스: core/port/out/mail_repository.go                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  GetByExternalIDs(ctx, connectionID int64, externalIDs []string)    │   │
│  │      (map[string]*MailEntity, error)                                │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  Task 0-2: mail.go 배치 조회 적용                                            │
│  ─────────────────────────────────────────                                  │
│  상태: [x] 완료                                                             │
│                                                                             │
│  파일: adapter/in/http/mail.go                                             │
│  함수: fetchFromProviderWithToken()                                        │
│                                                                             │
│  Before:                                                                    │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  for _, msg := range listResult.Messages {                          │   │
│  │      existing, _ := h.mailRepo.GetByExternalID(ctx, connID, msg.ID) │   │
│  │      // ❌ N+1 문제                                                 │   │
│  │  }                                                                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  After:                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  // 1. ExternalID 목록 추출                                         │   │
│  │  externalIDs := make([]string, len(listResult.Messages))            │   │
│  │  for i, msg := range listResult.Messages {                          │   │
│  │      externalIDs[i] = msg.ExternalID                                │   │
│  │  }                                                                  │   │
│  │                                                                     │   │
│  │  // 2. 배치 조회 (1번의 DB 쿼리)                                    │   │
│  │  existingMap, _ := h.mailRepo.GetByExternalIDs(ctx, connID, extIDs) │   │
│  │                                                                     │   │
│  │  // 3. 결과 매핑                                                    │   │
│  │  for _, msg := range listResult.Messages {                          │   │
│  │      if existing, ok := existingMap[msg.ExternalID]; ok {           │   │
│  │          email.ID = existing.ID                                     │   │
│  │      }                                                              │   │
│  │  }                                                                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  Task 0-3: sync.go 배치 조회 적용                                            │
│  ─────────────────────────────────────────                                  │
│  상태: [x] 완료                                                             │
│                                                                             │
│  파일: core/service/mail/sync.go                                           │
│  함수: processMessages(), saveEmailWithBody()                              │
│                                                                             │
│  변경 내용:                                                                 │
│  - processMessages(): 배치 중복 체크 후 새 메일만 저장                      │
│  - saveEmailWithBody(): 개별 체크 제거 (이미 필터링됨)                      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  Task 0-4: mail_processor.go 배치 조회 적용                                  │
│  ─────────────────────────────────────────                                  │
│  상태: [x] 완료                                                             │
│                                                                             │
│  파일: adapter/in/worker/mail_processor.go                                 │
│  함수: ProcessSave()                                                       │
│                                                                             │
│  변경 내용:                                                                 │
│  - 개별 GetByExternalID → 배치 GetByExternalIDs                            │
│  - 새 메일만 필터링 후 BulkUpsert                                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  Task 0-5: go-pkgz/pool Worker Pool 교체                                     │
│  ─────────────────────────────────────────                                  │
│  상태: [x] 완료                                                             │
│                                                                             │
│  설치: go get github.com/go-pkgz/pool                                      │
│                                                                             │
│  파일: adapter/in/worker/pool.go                                           │
│                                                                             │
│  현재 구조:                                                                 │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  type WorkerPool struct {                                           │   │
│  │      workers   int                                                  │   │
│  │      jobChan   chan *Job                                            │   │
│  │      // 단순 채널 기반                                              │   │
│  │  }                                                                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  변경 후:                                                                   │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  import "github.com/go-pkgz/pool"                                   │   │
│  │                                                                     │   │
│  │  type WorkerPool struct {                                           │   │
│  │      pool *pool.Worker[*Job]                                        │   │
│  │  }                                                                  │   │
│  │                                                                     │   │
│  │  func NewWorkerPool(workers int) *WorkerPool {                      │   │
│  │      p := pool.New[*Job](workers,                                   │   │
│  │          pool.WithBatchSize(10),       // 배치 처리                 │   │
│  │          pool.WithContinueOnError(),   // 에러 무시                 │   │
│  │      )                                                              │   │
│  │      return &WorkerPool{pool: p}                                    │   │
│  │  }                                                                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  예상 성능: 41% 향상 (errgroup 대비)                                        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  Task 0-6: Redis 캐시 레이어                                                 │
│  ─────────────────────────────────────────                                  │
│  상태: [ ] 대기 (선택적 - 배치 조회로 충분할 수 있음)                        │
│                                                                             │
│  파일: adapter/out/cache/mail_cache.go (신규)                              │
│                                                                             │
│  구현:                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  type MailCache struct {                                            │   │
│  │      redis *redis.Client                                            │   │
│  │  }                                                                  │   │
│  │                                                                     │   │
│  │  // 키: email:exists:{connectionID}                                 │   │
│  │  // 값: Set<ExternalID>                                             │   │
│  │  // TTL: 5분                                                        │   │
│  │                                                                     │   │
│  │  func (c *MailCache) GetExistingIDs(                                │   │
│  │      ctx context.Context,                                           │   │
│  │      connectionID int64,                                            │   │
│  │      externalIDs []string,                                          │   │
│  │  ) (existing []string, missing []string)                            │   │
│  │                                                                     │   │
│  │  func (c *MailCache) AddExistingIDs(                                │   │
│  │      ctx context.Context,                                           │   │
│  │      connectionID int64,                                            │   │
│  │      externalIDs []string,                                          │   │
│  │  )                                                                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  플로우:                                                                    │
│  1. Redis SMEMBERS로 캐시 체크 (0.1ms)                                     │
│  2. 캐시 미스 → DB GetByExternalIDs (10ms)                                 │
│  3. 결과 Redis SADD로 캐싱                                                 │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

================================================================================
                         구현 우선순위
================================================================================

Phase 0: 성능 최적화 (긴급) ✅ 완료
  [x] Task 0-1: GetByExternalIDs 배치 조회 구현
  [x] Task 0-2: mail.go 배치 조회 적용
  [x] Task 0-3: sync.go 배치 조회 적용
  [x] Task 0-4: mail_processor.go 배치 조회 적용
  [x] Task 0-5: go-pkgz/pool Worker Pool 교체 (41% 성능 향상)
  [ ] Task 0-6: Redis 캐시 레이어 (선택적 - 필요시 추가)

Phase 1: 핵심 안정화
  [x] SyncState 테이블 확장 (retry_count, checkpoint 등)
  [x] Progressive Loading (최근 50개 즉시)
  [x] 자동 재시도 로직

Phase 2: Gap Sync
  [x] 앱 시작 시 Gap Check
  [x] History 404 처리 → Full Sync 트리거
  [ ] Watch 만료 자동 갱신

Phase 3: AI 최적화
  [ ] AI 작업 배치 처리 개선
  [ ] SSE 이벤트 세분화 (classified, summarized)
  [ ] AI 토글 설정

Phase 4: Offline-First
  [ ] Modifier Queue (액션 큐잉)
  [ ] 오프라인 감지 및 복구
  [ ] 충돌 해결 전략

================================================================================
                         예상 성능 개선
================================================================================

┌────────────────────┬─────────────────┬─────────────────┬───────────────────┐
│ 작업               │ Before          │ After           │ 개선              │
├────────────────────┼─────────────────┼─────────────────┼───────────────────┤
│ 50개 메일 중복체크 │ 500ms (N+1)     │ 10ms (배치)     │ 50배 ↑            │
│ Worker 처리        │ 1.878s          │ 1.105s          │ 41% ↑             │
│ 전체 응답 시간     │ ~650ms          │ ~20ms           │ 32배 ↑            │
│ Redis 캐시 히트    │ -               │ 0.1ms           │ 100배 ↑           │
└────────────────────┴─────────────────┴─────────────────┴───────────────────┘

================================================================================

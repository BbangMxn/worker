package persistence

import (
	"context"
	"database/sql"
	"fmt"
	"time"

	"github.com/goccy/go-json"

	"worker_server/core/port/out"

	"github.com/google/uuid"
	"github.com/jmoiron/sqlx"
	"github.com/lib/pq"
)

// CalendarAdapter implements out.CalendarRepository using PostgreSQL.
type CalendarAdapter struct {
	db *sqlx.DB
}

// NewCalendarAdapter creates a new CalendarAdapter.
func NewCalendarAdapter(db *sqlx.DB) *CalendarAdapter {
	return &CalendarAdapter{db: db}
}

// calendarRow represents the database row for calendar events.
type calendarRow struct {
	ID               int64           `db:"id"`
	UserID           uuid.UUID       `db:"user_id"`
	Provider         sql.NullString  `db:"provider"`
	ProviderID       sql.NullString  `db:"provider_id"`
	CalendarID       sql.NullString  `db:"calendar_id"`
	Title            string          `db:"title"`
	Description      sql.NullString  `db:"description"`
	Location         sql.NullString  `db:"location"`
	StartTime        time.Time       `db:"start_time"`
	EndTime          time.Time       `db:"end_time"`
	Timezone         string          `db:"timezone"`
	IsAllDay         bool            `db:"is_all_day"`
	IsRecurring      bool            `db:"is_recurring"`
	RecurrenceRule   sql.NullString  `db:"recurrence_rule"`
	RecurringEventID sql.NullInt64   `db:"recurring_event_id"`
	Attendees        json.RawMessage `db:"attendees"`
	OrganizerEmail   sql.NullString  `db:"organizer_email"`
	Status           string          `db:"status"`
	Visibility       string          `db:"visibility"`
	MeetingURL       sql.NullString  `db:"meeting_url"`
	MeetingProvider  sql.NullString  `db:"meeting_provider"`
	Reminders        json.RawMessage `db:"reminders"`
	AutoGenerated    bool            `db:"auto_generated"`
	RelatedEmailID   sql.NullInt64   `db:"related_email_id"`
	Color            sql.NullString  `db:"color"`
	Transparency     string          `db:"transparency"`
	Categories       pq.StringArray  `db:"categories"`
	Attachments      json.RawMessage `db:"attachments"`
	CreatedAt        time.Time       `db:"created_at"`
	UpdatedAt        time.Time       `db:"updated_at"`
	SyncedAt         sql.NullTime    `db:"synced_at"`
}

func (r *calendarRow) toEntity() *out.CalendarEventEntity {
	entity := &out.CalendarEventEntity{
		ID:            r.ID,
		UserID:        r.UserID,
		Title:         r.Title,
		StartTime:     r.StartTime,
		EndTime:       r.EndTime,
		Timezone:      r.Timezone,
		IsAllDay:      r.IsAllDay,
		IsRecurring:   r.IsRecurring,
		Status:        r.Status,
		Visibility:    r.Visibility,
		AutoGenerated: r.AutoGenerated,
		Transparency:  r.Transparency,
		Categories:    r.Categories,
		CreatedAt:     r.CreatedAt,
		UpdatedAt:     r.UpdatedAt,
	}

	if r.Provider.Valid {
		entity.Provider = r.Provider.String
	}
	if r.ProviderID.Valid {
		entity.ProviderID = r.ProviderID.String
	}
	if r.CalendarID.Valid {
		entity.CalendarID = r.CalendarID.String
	}
	if r.Description.Valid {
		entity.Description = r.Description.String
	}
	if r.Location.Valid {
		entity.Location = r.Location.String
	}
	if r.RecurrenceRule.Valid {
		entity.RecurrenceRule = r.RecurrenceRule.String
	}
	if r.RecurringEventID.Valid {
		entity.RecurringEventID = &r.RecurringEventID.Int64
	}
	if r.OrganizerEmail.Valid {
		entity.OrganizerEmail = r.OrganizerEmail.String
	}
	if r.MeetingURL.Valid {
		entity.MeetingURL = r.MeetingURL.String
	}
	if r.MeetingProvider.Valid {
		entity.MeetingProvider = r.MeetingProvider.String
	}
	if r.RelatedEmailID.Valid {
		entity.RelatedEmailID = &r.RelatedEmailID.Int64
	}
	if r.Color.Valid {
		entity.Color = r.Color.String
	}
	if r.SyncedAt.Valid {
		entity.SyncedAt = &r.SyncedAt.Time
	}

	// Parse attendees
	if len(r.Attendees) > 0 {
		var attendees []out.AttendeeEntity
		json.Unmarshal(r.Attendees, &attendees)
		entity.Attendees = attendees
	}

	// Parse reminders
	if len(r.Reminders) > 0 {
		var reminders []out.ReminderEntity
		json.Unmarshal(r.Reminders, &reminders)
		entity.Reminders = reminders
	}

	// Parse attachments
	if len(r.Attachments) > 0 {
		var attachments []out.CalendarAttachmentEntity
		json.Unmarshal(r.Attachments, &attachments)
		entity.Attachments = attachments
	}

	return entity
}

// Create creates a new calendar event.
func (a *CalendarAdapter) Create(ctx context.Context, event *out.CalendarEventEntity) error {
	if event.Timezone == "" {
		event.Timezone = "UTC"
	}
	if event.Status == "" {
		event.Status = "confirmed"
	}
	if event.Visibility == "" {
		event.Visibility = "default"
	}
	if event.Transparency == "" {
		event.Transparency = "opaque"
	}

	// Ensure valid JSON for nil slices (PostgreSQL requires valid JSON string, not []byte)
	attendeesJSON := "[]"
	if len(event.Attendees) > 0 {
		if data, err := json.Marshal(event.Attendees); err == nil {
			attendeesJSON = string(data)
		}
	}
	remindersJSON := "[]"
	if len(event.Reminders) > 0 {
		if data, err := json.Marshal(event.Reminders); err == nil {
			remindersJSON = string(data)
		}
	}
	attachmentsJSON := "[]"
	if len(event.Attachments) > 0 {
		if data, err := json.Marshal(event.Attachments); err == nil {
			attachmentsJSON = string(data)
		}
	}

	query := `
		INSERT INTO calendar_events (
			user_id, provider, provider_id, calendar_id, title, description, location,
			start_time, end_time, timezone, is_all_day, is_recurring, recurrence_rule,
			attendees, organizer_email, status, visibility, meeting_url, meeting_provider,
			reminders, auto_generated, related_email_id,
			color, transparency, categories, attachments
		) VALUES (
			$1, NULLIF($2, ''), NULLIF($3, ''), NULLIF($4, ''), $5, NULLIF($6, ''), NULLIF($7, ''),
			$8, $9, $10, $11, $12, NULLIF($13, ''),
			$14, NULLIF($15, ''), $16, $17, NULLIF($18, ''), NULLIF($19, ''),
			$20, $21, $22,
			NULLIF($23, ''), $24, $25, $26
		)
		RETURNING id, created_at, updated_at
	`

	return a.db.QueryRowxContext(ctx, query,
		event.UserID, event.Provider, event.ProviderID, event.CalendarID,
		event.Title, event.Description, event.Location,
		event.StartTime, event.EndTime, event.Timezone,
		event.IsAllDay, event.IsRecurring, event.RecurrenceRule,
		attendeesJSON, event.OrganizerEmail, event.Status, event.Visibility,
		event.MeetingURL, event.MeetingProvider, remindersJSON,
		event.AutoGenerated, event.RelatedEmailID,
		event.Color, event.Transparency, pq.Array(event.Categories), attachmentsJSON,
	).Scan(&event.ID, &event.CreatedAt, &event.UpdatedAt)
}

// Update updates a calendar event.
func (a *CalendarAdapter) Update(ctx context.Context, event *out.CalendarEventEntity) error {
	// Ensure valid JSON for nil slices (PostgreSQL requires valid JSON string)
	attendeesJSON := "[]"
	if len(event.Attendees) > 0 {
		if data, err := json.Marshal(event.Attendees); err == nil {
			attendeesJSON = string(data)
		}
	}
	remindersJSON := "[]"
	if len(event.Reminders) > 0 {
		if data, err := json.Marshal(event.Reminders); err == nil {
			remindersJSON = string(data)
		}
	}
	attachmentsJSON := "[]"
	if len(event.Attachments) > 0 {
		if data, err := json.Marshal(event.Attachments); err == nil {
			attachmentsJSON = string(data)
		}
	}

	query := `
		UPDATE calendar_events SET
			title = $1, description = NULLIF($2, ''), location = NULLIF($3, ''),
			start_time = $4, end_time = $5, timezone = $6,
			is_all_day = $7, is_recurring = $8, recurrence_rule = NULLIF($9, ''),
			attendees = $10, organizer_email = NULLIF($11, ''),
			status = $12, visibility = $13,
			meeting_url = NULLIF($14, ''), meeting_provider = NULLIF($15, ''),
			reminders = $16, color = NULLIF($17, ''),
			transparency = $18, categories = $19, attachments = $20,
			updated_at = NOW()
		WHERE id = $21 AND user_id = $22
	`

	result, err := a.db.ExecContext(ctx, query,
		event.Title, event.Description, event.Location,
		event.StartTime, event.EndTime, event.Timezone,
		event.IsAllDay, event.IsRecurring, event.RecurrenceRule,
		attendeesJSON, event.OrganizerEmail,
		event.Status, event.Visibility,
		event.MeetingURL, event.MeetingProvider,
		remindersJSON, event.Color,
		event.Transparency, pq.Array(event.Categories), attachmentsJSON,
		event.ID, event.UserID,
	)
	if err != nil {
		return err
	}

	rows, _ := result.RowsAffected()
	if rows == 0 {
		return fmt.Errorf("calendar event not found")
	}
	return nil
}

// Delete deletes a calendar event.
func (a *CalendarAdapter) Delete(ctx context.Context, userID uuid.UUID, id int64) error {
	query := `DELETE FROM calendar_events WHERE id = $1 AND user_id = $2`

	result, err := a.db.ExecContext(ctx, query, id, userID)
	if err != nil {
		return err
	}

	rows, _ := result.RowsAffected()
	if rows == 0 {
		return fmt.Errorf("calendar event not found")
	}
	return nil
}

// GetByID gets a calendar event by ID.
func (a *CalendarAdapter) GetByID(ctx context.Context, userID uuid.UUID, id int64) (*out.CalendarEventEntity, error) {
	query := `SELECT * FROM calendar_events WHERE id = $1 AND user_id = $2`

	var row calendarRow
	err := a.db.QueryRowxContext(ctx, query, id, userID).StructScan(&row)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("calendar event not found")
		}
		return nil, err
	}

	return row.toEntity(), nil
}

// List lists calendar events with filters.
func (a *CalendarAdapter) List(ctx context.Context, userID uuid.UUID, query *out.CalendarListQuery) ([]*out.CalendarEventEntity, int, error) {
	if query == nil {
		query = &out.CalendarListQuery{}
	}
	if query.Limit <= 0 || query.Limit > 100 {
		query.Limit = 50
	}

	baseQuery := `FROM calendar_events WHERE user_id = $1`
	args := []interface{}{userID}
	argIdx := 2

	if query.StartTime != nil {
		baseQuery += fmt.Sprintf(` AND end_time >= $%d`, argIdx)
		args = append(args, *query.StartTime)
		argIdx++
	}

	if query.EndTime != nil {
		baseQuery += fmt.Sprintf(` AND start_time <= $%d`, argIdx)
		args = append(args, *query.EndTime)
		argIdx++
	}

	if query.CalendarID != "" {
		baseQuery += fmt.Sprintf(` AND calendar_id = $%d`, argIdx)
		args = append(args, query.CalendarID)
		argIdx++
	}

	if query.Provider != "" {
		baseQuery += fmt.Sprintf(` AND provider = $%d`, argIdx)
		args = append(args, query.Provider)
		argIdx++
	}

	if query.Status != "" {
		baseQuery += fmt.Sprintf(` AND status = $%d`, argIdx)
		args = append(args, query.Status)
		argIdx++
	}

	if query.Search != "" {
		baseQuery += fmt.Sprintf(` AND (title ILIKE $%d OR description ILIKE $%d OR location ILIKE $%d)`, argIdx, argIdx, argIdx)
		args = append(args, "%"+query.Search+"%")
		argIdx++
	}

	// Count
	var total int
	countQuery := `SELECT COUNT(*) ` + baseQuery
	if err := a.db.QueryRowxContext(ctx, countQuery, args...).Scan(&total); err != nil {
		return nil, 0, err
	}

	selectQuery := fmt.Sprintf(`SELECT * %s ORDER BY start_time ASC LIMIT $%d OFFSET $%d`,
		baseQuery, argIdx, argIdx+1)
	args = append(args, query.Limit, query.Offset)

	rows, err := a.db.QueryxContext(ctx, selectQuery, args...)
	if err != nil {
		return nil, 0, err
	}
	defer rows.Close()

	var events []*out.CalendarEventEntity
	for rows.Next() {
		var row calendarRow
		if err := rows.StructScan(&row); err != nil {
			return nil, 0, err
		}
		events = append(events, row.toEntity())
	}

	return events, total, nil
}

// GetUpcoming gets upcoming events.
func (a *CalendarAdapter) GetUpcoming(ctx context.Context, userID uuid.UUID, limit int) ([]*out.CalendarEventEntity, error) {
	if limit <= 0 || limit > 100 {
		limit = 10
	}

	query := `
		SELECT * FROM calendar_events
		WHERE user_id = $1 AND start_time >= NOW() AND status != 'cancelled'
		ORDER BY start_time ASC
		LIMIT $2
	`

	rows, err := a.db.QueryxContext(ctx, query, userID, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var events []*out.CalendarEventEntity
	for rows.Next() {
		var row calendarRow
		if err := rows.StructScan(&row); err != nil {
			return nil, err
		}
		events = append(events, row.toEntity())
	}

	return events, nil
}

// SaveResponse saves an attendee response.
func (a *CalendarAdapter) SaveResponse(ctx context.Context, response *out.AttendeeResponseEntity) error {
	query := `
		INSERT INTO calendar_attendee_responses (event_id, user_id, email, response, response_comment, responded_at)
		VALUES ($1, $2, $3, $4, NULLIF($5, ''), NOW())
		ON CONFLICT (event_id, email) DO UPDATE SET
			response = EXCLUDED.response,
			response_comment = COALESCE(EXCLUDED.response_comment, calendar_attendee_responses.response_comment),
			responded_at = NOW(),
			updated_at = NOW()
		RETURNING id, created_at, updated_at
	`

	return a.db.QueryRowxContext(ctx, query,
		response.EventID, response.UserID, response.Email,
		response.Response, response.ResponseComment,
	).Scan(&response.ID, &response.CreatedAt, &response.UpdatedAt)
}

// GetResponses gets attendee responses for an event.
func (a *CalendarAdapter) GetResponses(ctx context.Context, eventID int64) ([]*out.AttendeeResponseEntity, error) {
	query := `SELECT * FROM calendar_attendee_responses WHERE event_id = $1 ORDER BY responded_at DESC`

	rows, err := a.db.QueryxContext(ctx, query, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var responses []*out.AttendeeResponseEntity
	for rows.Next() {
		var r struct {
			ID              int64        `db:"id"`
			EventID         int64        `db:"event_id"`
			UserID          uuid.UUID    `db:"user_id"`
			Email           string       `db:"email"`
			Name            string       `db:"name"`
			Response        string       `db:"response"`
			ResponseComment string       `db:"response_comment"`
			RespondedAt     sql.NullTime `db:"responded_at"`
			CreatedAt       time.Time    `db:"created_at"`
			UpdatedAt       time.Time    `db:"updated_at"`
		}
		if err := rows.StructScan(&r); err != nil {
			return nil, err
		}

		entity := &out.AttendeeResponseEntity{
			ID:              r.ID,
			EventID:         r.EventID,
			UserID:          r.UserID,
			Email:           r.Email,
			Name:            r.Name,
			Response:        r.Response,
			ResponseComment: r.ResponseComment,
			CreatedAt:       r.CreatedAt,
			UpdatedAt:       r.UpdatedAt,
		}
		if r.RespondedAt.Valid {
			entity.RespondedAt = &r.RespondedAt.Time
		}
		responses = append(responses, entity)
	}

	return responses, nil
}

// Upsert upserts a calendar event from provider.
func (a *CalendarAdapter) Upsert(ctx context.Context, event *out.CalendarEventEntity) error {
	if event.Timezone == "" {
		event.Timezone = "UTC"
	}
	if event.Status == "" {
		event.Status = "confirmed"
	}
	if event.Visibility == "" {
		event.Visibility = "default"
	}

	// Ensure valid JSON for nil slices (PostgreSQL requires valid JSON string)
	attendeesJSON := "[]"
	if len(event.Attendees) > 0 {
		if data, err := json.Marshal(event.Attendees); err == nil {
			attendeesJSON = string(data)
		}
	}
	remindersJSON := "[]"
	if len(event.Reminders) > 0 {
		if data, err := json.Marshal(event.Reminders); err == nil {
			remindersJSON = string(data)
		}
	}

	query := `
		INSERT INTO calendar_events (
			user_id, provider, provider_id, calendar_id, title, description, location,
			start_time, end_time, timezone, is_all_day, is_recurring, recurrence_rule,
			attendees, organizer_email, status, visibility, meeting_url, meeting_provider,
			reminders, synced_at
		) VALUES (
			$1, $2, $3, $4, $5, NULLIF($6, ''), NULLIF($7, ''),
			$8, $9, $10, $11, $12, NULLIF($13, ''),
			$14, NULLIF($15, ''), $16, $17, NULLIF($18, ''), NULLIF($19, ''),
			$20, NOW()
		)
		ON CONFLICT (user_id, provider, provider_id) DO UPDATE SET
			calendar_id = EXCLUDED.calendar_id,
			title = EXCLUDED.title,
			description = COALESCE(EXCLUDED.description, calendar_events.description),
			location = COALESCE(EXCLUDED.location, calendar_events.location),
			start_time = EXCLUDED.start_time,
			end_time = EXCLUDED.end_time,
			timezone = EXCLUDED.timezone,
			is_all_day = EXCLUDED.is_all_day,
			is_recurring = EXCLUDED.is_recurring,
			recurrence_rule = COALESCE(EXCLUDED.recurrence_rule, calendar_events.recurrence_rule),
			attendees = EXCLUDED.attendees,
			organizer_email = COALESCE(EXCLUDED.organizer_email, calendar_events.organizer_email),
			status = EXCLUDED.status,
			visibility = EXCLUDED.visibility,
			meeting_url = COALESCE(EXCLUDED.meeting_url, calendar_events.meeting_url),
			meeting_provider = COALESCE(EXCLUDED.meeting_provider, calendar_events.meeting_provider),
			reminders = EXCLUDED.reminders,
			synced_at = NOW(),
			updated_at = NOW()
		RETURNING id, created_at, updated_at
	`

	return a.db.QueryRowxContext(ctx, query,
		event.UserID, event.Provider, event.ProviderID, event.CalendarID,
		event.Title, event.Description, event.Location,
		event.StartTime, event.EndTime, event.Timezone,
		event.IsAllDay, event.IsRecurring, event.RecurrenceRule,
		attendeesJSON, event.OrganizerEmail, event.Status, event.Visibility,
		event.MeetingURL, event.MeetingProvider, remindersJSON,
	).Scan(&event.ID, &event.CreatedAt, &event.UpdatedAt)
}

// =============================================================================
// Calendars Table Methods (for calendar list, not events)
// =============================================================================

// calendarListRow represents a row in the calendars table.
type calendarListRow struct {
	ID           int64          `db:"id"`
	UserID       uuid.UUID      `db:"user_id"`
	ConnectionID int64          `db:"connection_id"`
	Provider     string         `db:"provider"`
	ProviderID   string         `db:"provider_id"`
	Name         string         `db:"name"`
	Description  sql.NullString `db:"description"`
	Color        sql.NullString `db:"color"`
	IsDefault    bool           `db:"is_default"`
	IsReadOnly   bool           `db:"is_read_only"`
	CreatedAt    time.Time      `db:"created_at"`
	UpdatedAt    time.Time      `db:"updated_at"`
}

// CreateCalendarList creates a calendar entry in calendars table.
func (a *CalendarAdapter) CreateCalendarList(ctx context.Context, cal *out.CalendarListEntity) error {
	query := `
		INSERT INTO calendars (user_id, connection_id, provider, provider_id, name, description, color, is_default, is_read_only)
		VALUES ($1, $2, $3, $4, $5, NULLIF($6, ''), NULLIF($7, ''), $8, $9)
		ON CONFLICT (connection_id, provider_id) DO UPDATE SET
			name = EXCLUDED.name,
			description = COALESCE(EXCLUDED.description, calendars.description),
			color = COALESCE(EXCLUDED.color, calendars.color),
			is_default = EXCLUDED.is_default,
			updated_at = NOW()
		RETURNING id, created_at, updated_at
	`

	return a.db.QueryRowxContext(ctx, query,
		cal.UserID, cal.ConnectionID, cal.Provider, cal.ProviderID,
		cal.Name, cal.Description, cal.Color, cal.IsDefault, cal.IsReadOnly,
	).Scan(&cal.ID, &cal.CreatedAt, &cal.UpdatedAt)
}

// GetCalendarList gets a calendar by ID from calendars table.
func (a *CalendarAdapter) GetCalendarList(ctx context.Context, id int64) (*out.CalendarListEntity, error) {
	query := `SELECT * FROM calendars WHERE id = $1`

	var row calendarListRow
	err := a.db.QueryRowxContext(ctx, query, id).StructScan(&row)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return row.toCalendarListEntity(), nil
}

// GetCalendarListByProvider gets a calendar by provider ID.
func (a *CalendarAdapter) GetCalendarListByProvider(ctx context.Context, connectionID int64, providerID string) (*out.CalendarListEntity, error) {
	query := `SELECT * FROM calendars WHERE connection_id = $1 AND provider_id = $2`

	var row calendarListRow
	err := a.db.QueryRowxContext(ctx, query, connectionID, providerID).StructScan(&row)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return row.toCalendarListEntity(), nil
}

// ListCalendarsByUser lists all calendars for a user.
func (a *CalendarAdapter) ListCalendarsByUser(ctx context.Context, userID uuid.UUID) ([]*out.CalendarListEntity, error) {
	query := `SELECT * FROM calendars WHERE user_id = $1 ORDER BY is_default DESC, name ASC`

	rows, err := a.db.QueryxContext(ctx, query, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var calendars []*out.CalendarListEntity
	for rows.Next() {
		var row calendarListRow
		if err := rows.StructScan(&row); err != nil {
			return nil, err
		}
		calendars = append(calendars, row.toCalendarListEntity())
	}

	return calendars, nil
}

// ListCalendarsByConnection lists all calendars for a connection.
func (a *CalendarAdapter) ListCalendarsByConnection(ctx context.Context, connectionID int64) ([]*out.CalendarListEntity, error) {
	query := `SELECT * FROM calendars WHERE connection_id = $1 ORDER BY is_default DESC, name ASC`

	rows, err := a.db.QueryxContext(ctx, query, connectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var calendars []*out.CalendarListEntity
	for rows.Next() {
		var row calendarListRow
		if err := rows.StructScan(&row); err != nil {
			return nil, err
		}
		calendars = append(calendars, row.toCalendarListEntity())
	}

	return calendars, nil
}

// DeleteCalendarList deletes a calendar from calendars table.
func (a *CalendarAdapter) DeleteCalendarList(ctx context.Context, id int64) error {
	query := `DELETE FROM calendars WHERE id = $1`
	_, err := a.db.ExecContext(ctx, query, id)
	return err
}

func (r *calendarListRow) toCalendarListEntity() *out.CalendarListEntity {
	entity := &out.CalendarListEntity{
		ID:           r.ID,
		UserID:       r.UserID,
		ConnectionID: r.ConnectionID,
		Provider:     r.Provider,
		ProviderID:   r.ProviderID,
		Name:         r.Name,
		IsDefault:    r.IsDefault,
		IsReadOnly:   r.IsReadOnly,
		CreatedAt:    r.CreatedAt,
		UpdatedAt:    r.UpdatedAt,
	}

	if r.Description.Valid {
		entity.Description = r.Description.String
	}
	if r.Color.Valid {
		entity.Color = r.Color.String
	}

	return entity
}

// Ensure CalendarAdapter implements out.CalendarRepository
var _ out.CalendarRepository = (*CalendarAdapter)(nil)
